# 1 栈
分为数组栈、链表栈  
**数组栈**
```
class ArrayStackDemo{
    private int[] data;
    private int n;//栈的长度
    private int count;//栈中的数量

    public ArrayStackDemo(int n){
        this.data = new int[n];
        this.n = n;
        this.count = 0;
    }

    //入栈
    public boolean pushStack(int val){
        if(count==n){
            System.out.println("栈已满");
            return false;
        }

        data[count] = val;
        count += 1;
        return true;        
    }
    //出栈操作
    public boolean popStack(){
        if(count==0) return false;
        int tmp = data[count-1];
        count -= 1;
        return tmp;
    }

}
```
入栈复杂度分析：
在数组不扩容的情况下时间复杂度为O(1),需要扩容的情况下，均摊分析也为O(1)的复杂度。  
**应用**  
1、求表达式的值  
数字进栈，运算符进栈，**若当前运算符优先级低于或等于栈顶运算符**，则进行弹出运算符栈，和数字栈进行运算。
![表达式](./栈表达式.jpg)

2、对括号进行匹配分析  
按照左括号进行A栈，右边括号和栈顶括号匹配。

3、浏览器的“前进”“后退”操作  
每打开一个网页则放进A栈，若后退则将A栈弹出，进入B栈。从新打开一个新的网页（不是前进或者后退操作）则清空B栈。


# 2 队列

队列基本特点就是先进先出，尾部进，头部出。可以基于数组或链表实现队列。基于数组实现的队列为顺序队列，基于链表实现的是链式队列。链式队列可以利用零散内存，但是每个节点需要额外空间存储指针。顺序队列的不需要额外空间存储指针，**但是存在一个问题：随着队列进队、出队操作，头尾标志会逐渐向后移动，在尾标志移动到数组最后一个时，需要进行数据搬移。**均摊分析后，进队操作的时间复杂度O(1).同时，避免对顺序队列的搬移操作，可以设计采用循环队列。  

循环队列的特点是：需要判断好队列空（tail==head）队列满（(tail+1)%len==head）的条件  

![循环队列](./循环队列.jpg)

*更高级的还有：* 阻塞队列(生产-消费者模型)、并发队列

**“有限资源下，通过队列对请求、线程、。。。进行排队”**

# 3 递归

递归需要满足的三个条件  
+ 可以拆分成一个或者多个子问题
+ 子问题除数据规模不一致外，解决思路一致
+ 子问题有界，存在终止条件  
**递归公式**、**终止条件**

递归中的问题：
### 重复计算
通过哈希表存储解决
### 栈溢出
设置递归层数，防止过深






